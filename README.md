# ktest
Тестовое задание в одну секретную компанию.

Для запуска нужен только Python 3.5. Задачи выполнялись в предположении, что данные помещаются в память.

Задание 1
=========

Не выполнялось.

Задание 2
=========

Программа task2.py. Запуск:

```python3 task2.py path/to/spec_dt.txt path/to/out.txt```

Результат - таблица, выводится в файл, указанный в качестве второго аргумента.

Вычислительная сложность задачи ограничена сверху необходимостью так или иначе отсортировать все значения в таблице (т.е. ```O(N log N)```). Я пробовал также вариант с NumPy и простой сортировкой таблицы по двум полям (названию и значению признака), но он несколько усложняет алгоритм вывода результатов, а заметного прироста в скорости не дает.

Задание 3
=========

Программа task3.py. Запуск:

```python3 task3.py path/to/fdr.txt [--fdr 0.05]```

Результат выводится в консоль.

Предлагаемый алгоритм заключается в том, чтобы выбирать по порядку значения из отсортированного по value в обратном порядке списка до тех пор, пока FDR не станет больше заданного порога (по умолчанию 0.05). После этого выводится предыдущее значение value. Сложность алгоритма ```O(N log N)```. Реализация аналогичного алгоритма с использованием NumPy получилась медленнее.